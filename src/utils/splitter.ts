/**
 * Change splitting utilities
 * Decomposes large OpenSpec changes into phased sub-changes
 */

import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';
import { join } from 'path';
import { loadChange, parseTasks } from './openspec.js';
import { PhaseDefinition, SplitResult, PhaseInfo, PhaseManifest } from '../types.js';

const OPENSPEC_ROOT = 'openspec';
const CHANGES_DIR = join(OPENSPEC_ROOT, 'changes');

/**
 * Generate phase proposal.md content with frontmatter
 */
function generatePhaseProposal(
  originalChangeId: string,
  phaseNumber: number,
  totalPhases: number,
  description: string,
  originalProposal: string | undefined,
  dependsOn: string[]
): string {
  // Extract title from original proposal
  let originalTitle = originalChangeId;
  if (originalProposal) {
    const titleMatch = originalProposal.match(/^#\s+(.+)$/m);
    if (titleMatch) {
      originalTitle = titleMatch[1];
    }
  }

  const frontmatter = `---
parent: ${originalChangeId}
phase: ${phaseNumber}
total_phases: ${totalPhases}
depends_on: [${dependsOn.map(d => `"${d}"`).join(', ')}]
---`;

  const content = `${frontmatter}

# ${originalTitle} - Phase ${phaseNumber}: ${description}

## Overview

This is phase ${phaseNumber} of ${totalPhases} for implementing "${originalTitle}".

${description}

## Scope

See tasks.md for the specific tasks included in this phase.

## Dependencies

${dependsOn.length > 0
    ? dependsOn.map(d => `- \`${d}\` must be completed first`).join('\n')
    : '- No dependencies (this is the first phase)'}

## Parent Change

Original change: \`openspec/changes/${originalChangeId}/\`

---
*Generated by /split on ${new Date().toISOString()}*
`;

  return content;
}

/**
 * Generate phase tasks.md content
 */
function generatePhaseTasks(
  tasks: { id: string; description: string; completed: boolean }[],
  taskIndices: number[],
  description: string
): string {
  const phaseTasks = taskIndices
    .map(index => tasks[index - 1]) // Convert 1-based to 0-based
    .filter(Boolean);

  const taskLines = phaseTasks.map(
    task => `- [${task.completed ? 'x' : ' '}] ${task.description}`
  );

  return `# Tasks: ${description}

${taskLines.join('\n')}

---
*Generated by /split on ${new Date().toISOString()}*
`;
}

/**
 * Update original proposal.md with split status
 */
function markOriginalAsSplit(originalProposal: string, phaseChangeIds: string[]): string {
  // Add split frontmatter if not present, or update if present
  const hasFrontmatter = originalProposal.startsWith('---');

  const splitFrontmatter = `---
status: split
split_into: [${phaseChangeIds.map(id => `"${id}"`).join(', ')}]
split_date: "${new Date().toISOString()}"
---`;

  if (hasFrontmatter) {
    // Replace existing frontmatter
    const endOfFrontmatter = originalProposal.indexOf('---', 3);
    if (endOfFrontmatter !== -1) {
      return splitFrontmatter + originalProposal.slice(endOfFrontmatter + 3);
    }
  }

  // Prepend new frontmatter
  return splitFrontmatter + '\n\n' + originalProposal;
}

/**
 * Split a change into phased sub-changes
 */
export function splitChange(changeId: string, phases: PhaseDefinition[]): SplitResult {
  const change = loadChange(changeId);

  if (!change.tasks) {
    throw new Error(`Change ${changeId} has no tasks.md - cannot split`);
  }

  if (phases.length < 2) {
    throw new Error('Must specify at least 2 phases to split');
  }

  // Parse existing tasks
  const tasks = parseTasks(change.tasks);

  // Validate task indices
  for (const phase of phases) {
    for (const index of phase.taskIndices) {
      if (index < 1 || index > tasks.length) {
        throw new Error(`Invalid task index ${index} - tasks range from 1 to ${tasks.length}`);
      }
    }
  }

  // Create phase changes
  const phaseInfos: PhaseInfo[] = [];
  const phaseChangeIds: string[] = [];

  for (let i = 0; i < phases.length; i++) {
    const phase = phases[i];
    const phaseNumber = i + 1;
    const phaseChangeId = `${changeId}-phase${phaseNumber}`;
    const phasePath = join(CHANGES_DIR, phaseChangeId);
    const dependsOn = i > 0 ? [phaseChangeIds[i - 1]] : [];

    phaseChangeIds.push(phaseChangeId);

    // Create phase directory
    if (!existsSync(phasePath)) {
      mkdirSync(phasePath, { recursive: true });
    }

    // Generate and write proposal.md
    const proposalContent = generatePhaseProposal(
      changeId,
      phaseNumber,
      phases.length,
      phase.description,
      change.proposal,
      dependsOn
    );
    writeFileSync(join(phasePath, 'proposal.md'), proposalContent, 'utf-8');

    // Generate and write tasks.md
    const tasksContent = generatePhaseTasks(tasks, phase.taskIndices, phase.description);
    writeFileSync(join(phasePath, 'tasks.md'), tasksContent, 'utf-8');

    phaseInfos.push({
      changeId: phaseChangeId,
      path: phasePath,
      description: phase.description,
      taskCount: phase.taskIndices.length,
      dependsOn,
    });
  }

  // Create phases.yaml manifest in original change
  const manifest: PhaseManifest = {
    splitDate: new Date().toISOString(),
    status: 'split',
    phases: phaseInfos.map(p => ({
      id: p.changeId,
      description: p.description,
      dependsOn: p.dependsOn,
    })),
  };

  const manifestPath = join(change.path, 'phases.yaml');
  const yamlContent = `# Generated by /split
split_date: "${manifest.splitDate}"
status: ${manifest.status}
phases:
${manifest.phases.map(p => `  - id: "${p.id}"
    description: "${p.description}"
    depends_on: [${p.dependsOn.map(d => `"${d}"`).join(', ')}]`).join('\n')}
`;
  writeFileSync(manifestPath, yamlContent, 'utf-8');

  // Update original proposal.md with split status
  if (change.proposal) {
    const updatedProposal = markOriginalAsSplit(change.proposal, phaseChangeIds);
    writeFileSync(join(change.path, 'proposal.md'), updatedProposal, 'utf-8');
  }

  return {
    originalChangeId: changeId,
    phases: phaseInfos,
    manifestPath,
  };
}
